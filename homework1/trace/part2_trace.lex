/*
 * TRACING VERSION - part2_trace.lex
 * This version prints detailed information about each token
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../part2_helpers.h"
#include "part2_trace.tab.h"  /* Generated by Bison */

int line_number = 1;
FILE *trace_file = NULL;  /* File to write trace output */

void trace_token(const char *token_type, const char *token_name, const char *lexeme) {
    if (trace_file == NULL) {
        trace_file = fopen("trace_output.txt", "w");
        fprintf(trace_file, "=== LEXER TRACE - TOKEN GENERATION ===\n\n");
    }
    fprintf(trace_file, "[LEXER] Line %d: Found '%s'\n", line_number, lexeme ? lexeme : token_name);
    fprintf(trace_file, "        Token Type: %s\n", token_type);
    fprintf(trace_file, "        Creating node: type='%s', value='%s'\n", 
            token_name, lexeme ? lexeme : "NULL");
    fprintf(trace_file, "        Returning token: %s\n\n", token_type);
}
%}

%option noyywrap

/* Macro definitions for regular expressions */
id          [a-zA-Z][a-zA-Z0-9_]*
integernum  [0-9]+
realnum     [0-9]+\.[0-9]+
str         \"([^\n\r\"\\]|\\[nt\"])*\"

%%

    /* Reserved words */
"int"       { 
              trace_token("INT", "int", NULL);
              yylval.node = makeNode("int", NULL, NULL); 
              return INT; 
            }
"float"     { 
              trace_token("FLOAT", "float", NULL);
              yylval.node = makeNode("float", NULL, NULL); 
              return FLOAT; 
            }
"void"      { 
              trace_token("VOID", "void", NULL);
              yylval.node = makeNode("void", NULL, NULL); 
              return VOID; 
            }
"write"     { 
              trace_token("WRITE", "write", NULL);
              yylval.node = makeNode("write", NULL, NULL); 
              return WRITE; 
            }
"read"      { 
              trace_token("READ", "read", NULL);
              yylval.node = makeNode("read", NULL, NULL); 
              return READ; 
            }
"while"     { 
              trace_token("WHILE", "while", NULL);
              yylval.node = makeNode("while", NULL, NULL); 
              return WHILE; 
            }
"do"        { 
              trace_token("DO", "do", NULL);
              yylval.node = makeNode("do", NULL, NULL); 
              return DO; 
            }
"if"        { 
              trace_token("IF", "if", NULL);
              yylval.node = makeNode("if", NULL, NULL); 
              return IF; 
            }
"then"      { 
              trace_token("THEN", "then", NULL);
              yylval.node = makeNode("then", NULL, NULL); 
              return THEN; 
            }
"else"      { 
              trace_token("ELSE", "else", NULL);
              yylval.node = makeNode("else", NULL, NULL); 
              return ELSE; 
            }
"return"    { 
              trace_token("RETURN", "return", NULL);
              yylval.node = makeNode("return", NULL, NULL); 
              return RETURN; 
            }

    /* Symbols */
"("         { 
              trace_token("LPAREN", "(", NULL);
              yylval.node = makeNode("(", NULL, NULL); 
              return LPAREN; 
            }
")"         { 
              trace_token("RPAREN", ")", NULL);
              yylval.node = makeNode(")", NULL, NULL); 
              return RPAREN; 
            }
"{"         { 
              trace_token("LBRACE", "{", NULL);
              yylval.node = makeNode("{", NULL, NULL); 
              return LBRACE; 
            }
"}"         { 
              trace_token("RBRACE", "}", NULL);
              yylval.node = makeNode("}", NULL, NULL); 
              return RBRACE; 
            }
","         { 
              trace_token("COMMA", ",", NULL);
              yylval.node = makeNode(",", NULL, NULL); 
              return COMMA; 
            }
";"         { 
              trace_token("SEMICOLON", ";", NULL);
              yylval.node = makeNode(";", NULL, NULL); 
              return SEMICOLON; 
            }
":"         { 
              trace_token("COLON", ":", NULL);
              yylval.node = makeNode(":", NULL, NULL); 
              return COLON; 
            }

    /* Complex tokens */
{id}        { 
              trace_token("ID", "id", yytext);
              yylval.node = makeNode("id", yytext, NULL); 
              return ID; 
            }
{integernum} { 
              trace_token("INTEGERNUM", "integernum", yytext);
              yylval.node = makeNode("integernum", yytext, NULL); 
              return INTEGERNUM; 
            }
{realnum}   { 
              trace_token("REALNUM", "realnum", yytext);
              yylval.node = makeNode("realnum", yytext, NULL); 
              return REALNUM; 
            }
{str}       { 
              int len = strlen(yytext);
              char *str_val = (char*)malloc(len - 1);
              strncpy(str_val, yytext + 1, len - 2);
              str_val[len - 2] = '\0';
              trace_token("STR", "str", str_val);
              yylval.node = makeNode("str", str_val, NULL);
              free(str_val);
              return STR;
            }

    /* Relational operators */
"=="        { 
              trace_token("RELOP", "relop", "==");
              yylval.node = makeNode("relop", "==", NULL); 
              return RELOP; 
            }
"<>"        { 
              trace_token("RELOP", "relop", "<>");
              yylval.node = makeNode("relop", "<>", NULL); 
              return RELOP; 
            }
"<="        { 
              trace_token("RELOP", "relop", "<=");
              yylval.node = makeNode("relop", "<=", NULL); 
              return RELOP; 
            }
">="        { 
              trace_token("RELOP", "relop", ">=");
              yylval.node = makeNode("relop", ">=", NULL); 
              return RELOP; 
            }
"<"         { 
              trace_token("RELOP", "relop", "<");
              yylval.node = makeNode("relop", "<", NULL); 
              return RELOP; 
            }
">"         { 
              trace_token("RELOP", "relop", ">");
              yylval.node = makeNode("relop", ">", NULL); 
              return RELOP; 
            }

    /* Arithmetic operators */
"+"         { 
              trace_token("ADDOP", "addop", "+");
              yylval.node = makeNode("addop", "+", NULL); 
              return ADDOP; 
            }
"-"         { 
              trace_token("ADDOP", "addop", "-");
              yylval.node = makeNode("addop", "-", NULL); 
              return ADDOP; 
            }
"*"         { 
              trace_token("MULOP", "mulop", "*");
              yylval.node = makeNode("mulop", "*", NULL); 
              return MULOP; 
            }
"/"         { 
              trace_token("MULOP", "mulop", "/");
              yylval.node = makeNode("mulop", "/", NULL); 
              return MULOP; 
            }

    /* Assignment operator */
"="         { 
              trace_token("ASSIGN", "assign", "=");
              yylval.node = makeNode("assign", "=", NULL); 
              return ASSIGN; 
            }

    /* Logical operators */
"&&"        { 
              trace_token("AND", "and", "&&");
              yylval.node = makeNode("and", "&&", NULL); 
              return AND; 
            }
"||"        { 
              trace_token("OR", "or", "||");
              yylval.node = makeNode("or", "||", NULL); 
              return OR; 
            }
"!"         { 
              trace_token("NOT", "not", "!");
              yylval.node = makeNode("not", "!", NULL); 
              return NOT; 
            }

    /* Comments - ignore everything from # to end of line */
#[^\r\n]*   { 
              if (trace_file) {
                  fprintf(trace_file, "[LEXER] Line %d: Comment ignored: '%s'\n\n", line_number, yytext);
              }
            }

    /* Whitespace */
[ \t]       { /* Ignore whitespace */ }
\n          { line_number++; }
\r\n        { line_number++; }

    /* Error handling */
.           { 
              fprintf(stderr, "Lexical error: '%s' in line number %d\n", yytext, line_number);
              if (trace_file) {
                  fprintf(trace_file, "[LEXER ERROR] Line %d: Invalid character '%s'\n\n", line_number, yytext);
                  fclose(trace_file);
              }
              exit(1);
            }

%%
