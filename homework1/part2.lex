/*
 * Compilation Course - Project Part 2
 * Lexical Analyzer for C-- Language (Parser Version)
 * Student IDs: 322449539, 323885350
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "part2_helpers.h"
#include "part2.tab.h"  /* Generated by Bison */

int line_number = 1;
%}

%option noyywrap

/* Macro definitions for regular expressions */
id          [a-zA-Z][a-zA-Z0-9_]*
integernum  [0-9]+
realnum     [0-9]+\.[0-9]+
str         \"([^\n\r\"\\]|\\[nt\"])*\"

%%

    /* Reserved words */
"int"       { yylval.node = makeNode("int", NULL, NULL); return INT; }
"float"     { yylval.node = makeNode("float", NULL, NULL); return FLOAT; }
"void"      { yylval.node = makeNode("void", NULL, NULL); return VOID; }
"write"     { yylval.node = makeNode("write", NULL, NULL); return WRITE; }
"read"      { yylval.node = makeNode("read", NULL, NULL); return READ; }
"while"     { yylval.node = makeNode("while", NULL, NULL); return WHILE; }
"do"        { yylval.node = makeNode("do", NULL, NULL); return DO; }
"if"        { yylval.node = makeNode("if", NULL, NULL); return IF; }
"then"      { yylval.node = makeNode("then", NULL, NULL); return THEN; }
"else"      { yylval.node = makeNode("else", NULL, NULL); return ELSE; }
"return"    { yylval.node = makeNode("return", NULL, NULL); return RETURN; }

    /* Symbols */
"("         { yylval.node = makeNode("(", NULL, NULL); return LPAREN; }
")"         { yylval.node = makeNode(")", NULL, NULL); return RPAREN; }
"{"         { yylval.node = makeNode("{", NULL, NULL); return LBRACE; }
"}"         { yylval.node = makeNode("}", NULL, NULL); return RBRACE; }
","         { yylval.node = makeNode(",", NULL, NULL); return COMMA; }
";"         { yylval.node = makeNode(";", NULL, NULL); return SEMICOLON; }
":"         { yylval.node = makeNode(":", NULL, NULL); return COLON; }

    /* Complex tokens */
{id}        { yylval.node = makeNode("id", yytext, NULL); return ID; }
{integernum} { yylval.node = makeNode("integernum", yytext, NULL); return INTEGERNUM; }
{realnum}   { yylval.node = makeNode("realnum", yytext, NULL); return REALNUM; }
{str}       { 
              /* Extract string content without quotes */
              int len = strlen(yytext);
              char *str_val = (char*)malloc(len - 1);
              strncpy(str_val, yytext + 1, len - 2);
              str_val[len - 2] = '\0';
              yylval.node = makeNode("str", str_val, NULL);
              free(str_val);
              return STR;
            }

    /* Relational operators */
"=="        { yylval.node = makeNode("relop", "==", NULL); return RELOP; }
"<>"        { yylval.node = makeNode("relop", "<>", NULL); return RELOP; }
"<="        { yylval.node = makeNode("relop", "<=", NULL); return RELOP; }
">="        { yylval.node = makeNode("relop", ">=", NULL); return RELOP; }
"<"         { yylval.node = makeNode("relop", "<", NULL); return RELOP; }
">"         { yylval.node = makeNode("relop", ">", NULL); return RELOP; }

    /* Arithmetic operators */
"+"         { yylval.node = makeNode("addop", "+", NULL); return ADDOP; }
"-"         { yylval.node = makeNode("addop", "-", NULL); return ADDOP; }
"*"         { yylval.node = makeNode("mulop", "*", NULL); return MULOP; }
"/"         { yylval.node = makeNode("mulop", "/", NULL); return MULOP; }

    /* Assignment operator */
"="         { yylval.node = makeNode("assign", "=", NULL); return ASSIGN; }

    /* Logical operators */
"&&"        { yylval.node = makeNode("and", "&&", NULL); return AND; }
"||"        { yylval.node = makeNode("or", "||", NULL); return OR; }
"!"         { yylval.node = makeNode("not", "!", NULL); return NOT; }

    /* Comments - ignore everything from # to end of line */
#[^\r\n]*   { /* Ignore comments */ }

    /* Whitespace */
[ \t]       { /* Ignore whitespace */ }
\n          { line_number++; }
\r\n        { line_number++; }

    /* Error handling */
.           { 
              fprintf(stderr, "Lexical error: '%s' in line number %d\n", yytext, line_number);
              exit(1);
            }

%%
